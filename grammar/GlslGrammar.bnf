{
    parserClass="glsl._GlslParser"
    psiClassPrefix="Glsl"
    psiImplClassSuffix="Impl"
    psiPackage="glsl.psi.interfaces"
    psiImplPackage="glsl.psi.impl"
    parserUtilClass="glsl.plugin.utils.GlslPsiUtils"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    elementTypeHolderClass="glsl.GlslTypes"
    elementTypeClass="glsl.plugin.language.GlslElementType"
    tokenTypeClass="glsl.plugin.language.GlslTokenType"

    implements("variable_identifier|type_name")="glsl.plugin.psi.GlslIdentifier"
    mixin("variable_identifier|type_name")="glsl.plugin.psi.GlslIdentifierImpl"
    implements("expr")="glsl.plugin.psi.GlslExprType"
    mixin("expr")="glsl.plugin.psi.GlslExprTypeImpl"
    // Types
    implements("struct_specifier")="glsl.plugin.psi.named.GlslNamedUserType"
    mixin("struct_specifier")="glsl.plugin.psi.named.GlslNamedStructSpecifier"
    implements("block_structure")="glsl.plugin.psi.named.GlslNamedUserType"
    mixin("block_structure")="glsl.plugin.psi.named.GlslNamedBlockStructure"
    // Identifiers
    implements("function_header")="glsl.plugin.psi.named.GlslNamedIdentifier"
    mixin("function_header")="glsl.plugin.psi.named.GlslNamedFunctionHeader"
    implements("parameter_declarator")="glsl.plugin.psi.named.GlslNamedIdentifier"
    mixin("parameter_declarator")="glsl.plugin.psi.named.GlslNamedParameterDeclarator"
    implements("single_declaration")="glsl.plugin.psi.named.GlslNamedIdentifier"
    mixin("single_declaration")="glsl.plugin.psi.named.GlslNamedSingleDeclaration"
    implements("init_declarator_variable")="glsl.plugin.psi.named.GlslNamedIdentifier"
    mixin("init_declarator_variable")="glsl.plugin.psi.named.GlslNamedInitDeclaratorVariable"
    implements("block_structure_wrapper")="glsl.plugin.psi.named.GlslNamedIdentifier"
    mixin("block_structure_wrapper")="glsl.plugin.psi.named.GlslNamedBlockStructureWrapper"
    implements("struct_declarator")="glsl.plugin.psi.named.GlslNamedIdentifier"
    mixin("struct_declarator")="glsl.plugin.psi.named.GlslNamedStructDeclarator"
    implements("declaration_identifier_wrapper")="glsl.plugin.psi.named.GlslNamedIdentifier"
    mixin("declaration_identifier_wrapper")="glsl.plugin.psi.named.GlslNamedDeclarationIdentifierWrapper"
    implements("pp_single_declaration")="glsl.plugin.psi.named.GlslNamedIdentifier"
    mixin("pp_single_declaration")="glsl.plugin.psi.named.GlslNamedPpSingleDeclaration"
    implements("pp_define_function")="glsl.plugin.psi.named.GlslNamedIdentifier"
    mixin("pp_define_function")="glsl.plugin.psi.named.GlslNamedPpDefineFunction"
    implements("pp_define_param")="glsl.plugin.psi.named.GlslNamedIdentifier"
    mixin("pp_define_param")="glsl.plugin.psi.named.GlslNamedPpDefineParam"


    extends("expr_no_assignment|assignment_expr")=expr
    extends("(comma_seperated|conditional|shift|relational|equality|and|exclusive_or|inclusive_or|logical_and|logical_xor|logical_or|mul|add|unary)_expr")=expr_no_assignment
    extends("postfix_inc|postfix_field_selection|postfix_array_index|primary_expr|function_call")=postfix_expr

    name("postfix.*|.*expr")="expression"
    name(".*statement|case_label")="statement"
    name(".*operator")="operator"
    name(".*qualifier")="qualifier"
    name("block_structure|function_prototype|single_declaration")="declration"
    name("type_specifier")="type"

    tokens = [
        WHITE_SPACE='regexp:[ \n\r\t\f]+'
        // Comments
        LINE_COMMENT='regexp://+.*'
        MULTILINE_COMMENT='regexp:/\*([\s\S]*?)\*/[ \t\n\x0B\f\r]*'
        // Preprocessors
        HASH="#"
        BACKSLASH="\\"
        PP_VERSION="#version"
        PP_DEFINE="#define"
        PP_UNDEF="#undef"
        PP_IF="#if"
        PP_IFDEF="#ifdef"
        PP_IFNDEF="#ifndef"
        PP_ELSE="#else"
        PP_ELIF="#elif"
        PP_ENDIF="#endif"
        PP_ERROR="#error"
        PP_PRAGMA="#pragma"
        PP_EXTENSION="#extension"
        PP_INCLUDE="#include"
        PP_LINE="#line"
        MACRO_LINE="__LINE__"
        MACRO_FILE="__FILE__"
        MACRO_VERSION="__VERSION__"
        // Punctuation
        SEMICOLON=";"
        COMMA=","
        COLON=":"
        EQUAL="="
        LEFT_PAREN="("
        RIGHT_PAREN=")"
        DOT="."
        BANG="!"
        DASH="-"
        TILDE="~"
        PLUS="+"
        STAR="*"
        SLASH="/"
        BACKSLASH="\\"
        PERCENT="%"
        LEFT_ANGLE="<"
        RIGHT_ANGLE=">"
        VERTICAL_BAR="|"
        CARET="^"
        AMPERSAND="&"
        QUESTION="?"
        LEFT_BRACKET="["
        RIGHT_BRACKET="]"
        LEFT_BRACE="{"
        RIGHT_BRACE="}"
        ADD_ASSIGN="+="
        SUB_ASSIGN="-="
        MUL_ASSIGN="*="
        DIV_ASSIGN="/="
        MOD_ASSIGN="%="
        RIGHT_ASSIGN=">>="
        LEFT_ASSIGN="<<="
        AND_ASSIGN="&="
        OR_ASSIGN="|="
        XOR_ASSIGN="^="
        RIGHT_OP=">>"
        LEFT_OP="<<"
        AND_OP="&&"
        OR_OP="||"
        XOR_OP="^^"
        EQ_OP="=="
        GE_OP="!="
        NE_OP=">="
        LE_OP="<="
        DEC_OP="--"
        INC_OP="++"
        COLONCOLON="::"
        // Types
        VOID="void"
        FLOAT="float"
        DOUBLE="double"
        INT="int"
        UINT="uint"
        BOOL="bool"
        MAT2="mat2"
        MAT3="mat3"
        MAT4="mat4"
        MAT2X2="mat2x2"
        MAT2X3="mat2x3"
        MAT2X4="mat2x4"
        MAT3X2="mat3x2"
        MAT3X3="mat3x3"
        MAT3X4="mat3x4"
        MAT4X2="mat4x2"
        MAT4X3="mat4x3"
        MAT4X4="mat4x4"
        DMAT2="dmat2"
        DMAT3="dmat3"
        DMAT4="dmat4"
        DMAT2X2="dmat2x2"
        DMAT2X3="dmat2x3"
        DMAT2X4="dmat2x4"
        DMAT3X2="dmat3x2"
        DMAT3X3="dmat3x3"
        DMAT3X4="dmat3x4"
        DMAT4X2="dmat4x2"
        DMAT4X3="dmat4x3"
        DMAT4X4="dmat4x4"
        ATOMIC_UINT="atomic_uint"
        SAMPLER2D="sampler2d"
        SAMPLER3D="sampler3d"
        SAMPLERCUBE="samplercube"
        SAMPLER2DSHADOW="sampler2dshadow"
        SAMPLERCUBESHADOW="samplercubeshadow"
        SAMPLER2DARRAY="sampler2darray"
        SAMPLER2DARRAYSHADOW="sampler2darrayshadow"
        SAMPLERCUBEARRAY="samplercubearray"
        SAMPLERCUBEARRAYSHADOW="samplercubearrayshadow"
        ISAMPLER2D="isampler2d"
        ISAMPLER3D="isampler3d"
        ISAMPLERCUBE="isamplercube"
        ISAMPLER2DARRAY="isampler2darray"
        ISAMPLERCUBEARRAY="isamplercubearray"
        USAMPLER2D="usampler2d"
        USAMPLER3D="usampler3d"
        USAMPLERCUBE="usamplercube"
        USAMPLER2DARRAY="usampler2darray"
        USAMPLERCUBEARRAY="usamplercubearray"
        SAMPLER1D="sampler1d"
        SAMPLER1DSHADOW="sampler1dshadow"
        SAMPLER1DARRAY="sampler1darray"
        SAMPLER1DARRAYSHADOW="sampler1darrayshadow"
        ISAMPLER1D="isampler1d"
        ISAMPLER1DARRAY="isampler1darray"
        USAMPLER1D="usampler1d"
        USAMPLER1DARRAY="usampler1darray"
        SAMPLER2DRECT="sampler2drect"
        SAMPLER2DRECTSHADOW="sampler2drectshadow"
        ISAMPLER2DRECT="isampler2drect"
        USAMPLER2DRECT="usampler2drect"
        SAMPLERBUFFER="samplerbuffer"
        ISAMPLERBUFFER="isamplerbuffer"
        USAMPLERBUFFER="usamplerbuffer"
        SAMPLER2DMS="sampler2dms"
        ISAMPLER2DMS="isampler2dms"
        USAMPLER2DMS="usampler2dms"
        SAMPLER2DMSARRAY="sampler2dmsarray"
        ISAMPLER2DMSARRAY="isampler2dmsarray"
        USAMPLER2DMSARRAY="usampler2dmsarray"
        IMAGE2D="image2d"
        IIMAGE2D="iimage2d"
        UIMAGE2D="uimage2d"
        IMAGE3D="image3d"
        IIMAGE3D="iimage3d"
        UIMAGE3D="uimage3d"
        IMAGECUBE="imagecube"
        IIMAGECUBE="iimagecube"
        UIMAGECUBE="uimagecube"
        IMAGEBUFFER="imagebuffer"
        IIMAGEBUFFER="iimagebuffer"
        UIMAGEBUFFER="uimagebuffer"
        IMAGE1D="image1d"
        IIMAGE1D="iimage1d"
        UIMAGE1D="uimage1d"
        IMAGE1DARRAY="image1darray"
        IIMAGE1DARRAY="iimage1darray"
        UIMAGE1DARRAY="uimage1darray"
        IMAGE2DRECT="image2drect"
        IIMAGE2DRECT="iimage2drect"
        UIMAGE2DRECT="uimage2drect"
        IMAGE2DARRAY="image2darray"
        IIMAGE2DARRAY="iimage2darray"
        UIMAGE2DARRAY="uimage2darray"
        IMAGECUBEARRAY="imagecubearray"
        IIMAGECUBEARRAY="iimagecubearray"
        UIMAGECUBEARRAY="uimagecubearray"
        IMAGE2DMS="image2dms"
        IIMAGE2DMS="iimage2dms"
        UIMAGE2DMS="uimage2dms"
        IMAGE2DMSARRAY="image2dmsarray"
        IIMAGE2DMSARRAY="iimage2dmsarray"
        UIMAGE2DMSARRAY="uimage2dmsarray"
        // sprirv
        SPIRV_EXECUTION_MODE="spirv_execution_mode"
        SPIRV_EXECUTION_MODE_ID="spirv_execution_mode_id"
        SPIRV_STORAGE_CLASS="spirv_storage_class"
        SPIRV_DECORATE="spirv_decorate"
        SPIRV_DECORATE_ID="spirv_decorate_id"
        SPIRV_DECORATE_STRING="spirv_decorate_string"
        SPIRV_TYPE="spirv_type"
        SPIRV_INSTRUCTION="spirv_instruction"
        SPIRV_BY_REFERENCE="spirv_by_reference"
        SPIRV_LITERAL="spirv_literal"
        // storage_qualifier
        CONST="const"
        INOUT="inout"
        IN="in"
        OUT="out"
        CENTROID="centroid"
        PATCH="patch"
        SAMPLE="sample"
        UNIFORM="uniform"
        BUFFER="buffer"
        COHERENT="coherent"
        VARYING="varying"
        VOLATILE="volatile"
        RESTRICT="restrict"
        READONLY="readonly"
        WRITEONLY="writeonly"
        SUBROUTINE="subroutine"
        // Control
        IF="if"
        ELSE="else"
        SWITCH="switch"
        CASE="case"
        DEFAULT="default"
        WHILE="while"
        DO="do"
        FOR="for"
        CONTINUE="continue"
        BREAK="break"
        RETURN="return"
        DISCARD="discard"
        // precision_qualifier
        HIGH_PRECISION="highp"
        MEDIUM_PRECISION="mediump"
        LOW_PRECISION="lowp"
        // interpolation_qualifier
        SMOOTH="smooth"
        FLAT="flat"
        EXPLICITINTERPAMD="explicitinterpamd"
        NOPERSPECTIVE="noperspective"
        PERVERTEXNV="pervertexnv"
        PERPRIMITIVENV="perprimitivenv"
        PERVIEWNV="perviewnv"
        PERTASKNV="pertasknv"
        // Rest (to be sorted)
        PRECISION="precision"
        DEMOTE="demote"
        TERMINATE_INVOCATION="terminate_invocation"
        TERMINATE_RAY="terminate_ray"
        IGNORE_INTERSECTION="ignore_intersection"
        INVARIANT="invariant"
        STRUCT="struct"
        LAYOUT="layout"
        SHARED="shared"
        PRECISE="precise"
        NONUNIFORM="nonuniform"
        ATTR="attr"
        HITATTRNV="hitattrnv"
        HITATTREXT="hitattrext"
        PAYLOADNV="payloadnv"
        PAYLOADEXT="payloadext"
        PAYLOADINNV="payloadinnv"
        PAYLOADINEXT="payloadinext"
        CALLDATANV="calldatanv"
        CALLDATAEXT="calldataext"
        CALLDATAINNV="calldatainnv"
        CALLDATAINEXT="calldatainext"
        DEVICECOHERENT="devicecoherent"
        QUEUEFAMILYCOHERENT="queuefamilycoherent"
        WORKGROUPCOHERENT="workgroupcoherent"
        SUBGROUPCOHERENT="subgroupcoherent"
        NONPRIVATE="nonprivate"
        SHADERCALLCOHERENT="shadercallcoherent"
        // User-defined
        FLOATCONSTANT="regexp:((\d+[.]\d+)|(\d+[.])|([.]\d+))f?"
        UINTCONSTANT="regexp:(0x[\da-fA-F]+|\d+)u|U"
        INTCONSTANT="regexp:0x[\da-fA-F]+|\d+"
        BOOLCONSTANT="regexp:false|true"
        STRING_LITERAL="regexp:(\"([^\"\\]|\[.])*\")"
        IDENTIFIER="regexp:[a-zA-Z_]+\w*"
        TYPE_NAME_IDENTIFIER="regexp:[a-zA-Z_]+\w*"
    ]
}

root ::= translation_unit*

private translation_unit
    ::= external_declaration

external_declaration
    ::= pp_statement
    |   function_definition
    |   declaration
    |   SEMICOLON

// *******************
// *** Declaration ***
// *******************
declaration
    ::= function_prototype SEMICOLON
    |   PRECISION precision_qualifier type_specifier SEMICOLON
	|   block_structure_wrapper SEMICOLON
	|   init_declarator_list SEMICOLON
	|   type_qualifier identifier_list? SEMICOLON
	|   spirv_instruction_qualifier function_prototype SEMICOLON
	|   spirv_execution_mode_qualifier SEMICOLON
    {   pin(".*")=1 }

function_definition
    ::= function_prototype compound_statement_no_new_scope

variable_identifier
    ::= IDENTIFIER

private init_declarator_list
    ::= single_declaration (COMMA init_declarator_variable array_specifier? (EQUAL initializer)?)*
    {   pin(".*")=1 }

init_declarator_variable
    ::= variable_identifier

single_declaration
    ::= fully_specified_type variable_identifier array_specifier? EQUAL initializer
    |   fully_specified_type variable_identifier EQUAL initializer
    |   fully_specified_type variable_identifier array_specifier?
    |   fully_specified_type
    {   pin(".*")="EQUAL" }

private initializer_list
    ::= initializer (COMMA initializer)*

private initializer
    ::= LEFT_BRACE initializer_list COMMA RIGHT_BRACE
	|   LEFT_BRACE initializer_list? RIGHT_BRACE
	|   expr_no_assignment

private identifier_list
	::= declaration_identifier_wrapper (COMMA declaration_identifier_wrapper)*

declaration_identifier_wrapper ::= variable_identifier

// *****************
// *** Statement ***
// *****************
statement
    ::= compound_statement
    |   simple_statement

private recover_statement ::= !(RIGHT_BRACE)

private statement_list
    ::= statement*
    {   recoverWhile=recover_statement  }

compound_statement
    ::= LEFT_BRACE statement_list? RIGHT_BRACE
    {   pin=2   }

compound_statement_no_new_scope
    ::= LEFT_BRACE statement_list? RIGHT_BRACE
    {   pin=2   }

private statement_no_new_scope
    ::= compound_statement_no_new_scope
	|   simple_statement

private statement_scoped
    ::= compound_statement
    |   simple_statement

private simple_statement
    ::= declaration_statement
    |   expr_statement
	|   selection_statement
	|   switch_statement
	|   iteration_statement
	|   jump_statement
	|   case_label
	|   demote_statement
	|   pp_statement

private expr_statement
    ::= expr SEMICOLON
    {   pin=1   }

private declaration_statement
    ::= declaration
    |   SEMICOLON

private demote_statement
    ::= DEMOTE SEMICOLON
    {   pin=1   }

selection_statement
    ::= attribute? selection_statement_nonattributed

private selection_statement_nonattributed
    ::= IF LEFT_PAREN expr RIGHT_PAREN selection_rest_statement
    {   pin=1   }

private selection_rest_statement
    ::= statement_scoped (ELSE statement_scoped)?

switch_statement
    ::= attribute? switch_statement_nonattributed

private switch_statement_nonattributed
    ::= SWITCH LEFT_PAREN expr RIGHT_PAREN LEFT_BRACE switch_statement_list RIGHT_BRACE
    {   pin=1   }

private switch_statement_list
    ::= statement_list

case_label
    ::= CASE expr COLON
	|   DEFAULT COLON
	{   pin(".*")=1    }

iteration_statement
    ::= attribute? iteration_statement_nonattributed

private iteration_statement_nonattributed
    ::= WHILE LEFT_PAREN condition RIGHT_PAREN statement_no_new_scope
	|   DO statement WHILE LEFT_PAREN expr RIGHT_PAREN SEMICOLON
	|   FOR LEFT_PAREN for_init_statement for_rest_statement RIGHT_PAREN statement_no_new_scope
    {   pin(".*")=1   }

private for_init_statement
    ::= expr_statement
	|   declaration_statement

private conditionopt
    ::= condition?

condition
    ::= expr (variable_identifier EQUAL initializer)?

for_rest_statement
    ::= conditionopt SEMICOLON expr?
    {   pin=1   }

jump_statement
    ::= CONTINUE SEMICOLON
	|   BREAK SEMICOLON
	|   RETURN expr? SEMICOLON
	|   DISCARD SEMICOLON
	|   TERMINATE_INVOCATION SEMICOLON
	|   TERMINATE_RAY SEMICOLON
	|   IGNORE_INTERSECTION SEMICOLON
	{   pin(".*")=1    }

// ******************
// *** Expression ***
// ******************
expr
    ::= assignment_expr
    |   expr_no_assignment (COMMA expr_no_assignment)*

// This rule should be like 'conditional_expr' in the original grammar, which have all
// expressions without assignment
expr_no_assignment
    ::= conditional_expr
    |   shift_expr
    |   relational_expr
    |   equality_expr
    |   and_expr
    |   exclusive_or_expr
    |   inclusive_or_expr
    |   logical_and_expr
    |   logical_xor_expr
    |   logical_or_expr
    |   mul_expr
    |   add_expr
    |   unary_expr

postfix_expr
    ::= postfix_array_index
    |   function_call
    |   postfix_field_selection
    |   postfix_inc
    |   primary_expr

private integer_expression
    ::= expr

postfix_inc
    ::= postfix_expr (INC_OP|DEC_OP)

postfix_struct_member
    ::= function_call
    |   variable_identifier (LEFT_BRACKET integer_expression RIGHT_BRACKET)?

postfix_field_selection
    ::= postfix_expr (DOT postfix_struct_member)+
    {   pin(".*")=1    }

postfix_array_index
    ::= postfix_expr (LEFT_BRACKET integer_expression RIGHT_BRACKET)+

primary_expr
    ::= variable_identifier
    |   LEFT_PAREN expr RIGHT_PAREN
    |   FLOATCONSTANT
    |   INTCONSTANT
    |   UINTCONSTANT
	|   BOOLCONSTANT
	|   STRING_LITERAL
    |   DOUBLECONSTANT
    |   MACRO_LINE
    |   MACRO_FILE
    |   MACRO_VERSION

unary_expr
    ::= (INC_OP | DEC_OP) postfix_expr
    |   unary_operator postfix_expr
    |   postfix_expr

private unary_operator
    ::= PLUS
    |   DASH
    |   BANG
    |   TILDE

mul_expr
    ::= expr_no_assignment (STAR | SLASH | PERCENT) expr_no_assignment

add_expr
    ::= expr_no_assignment (PLUS | DASH) expr_no_assignment

shift_expr
    ::= expr_no_assignment (LEFT_OP | RIGHT_OP) expr_no_assignment

relational_expr
    ::= expr_no_assignment (LEFT_ANGLE | RIGHT_ANGLE | LE_OP | GE_OP) expr_no_assignment

equality_expr
    ::= expr_no_assignment (EQ_OP | NE_OP) expr_no_assignment

and_expr
    ::= expr_no_assignment AMPERSAND expr_no_assignment

exclusive_or_expr
    ::= expr_no_assignment CARET expr_no_assignment

inclusive_or_expr
    ::= expr_no_assignment VERTICAL_BAR expr_no_assignment

logical_and_expr
    ::= expr_no_assignment AND_OP expr_no_assignment

logical_xor_expr
    ::= expr_no_assignment XOR_OP expr_no_assignment

logical_or_expr
    ::= expr_no_assignment OR_OP expr_no_assignment

conditional_expr
    ::= expr_no_assignment QUESTION expr_no_assignment COLON expr_no_assignment

assignment_expr
    ::= unary_expr assignment_operator expr
    {   pin(".*")=assignment_operator}

assignment_operator
    ::= EQUAL
	|   MUL_ASSIGN
	|   DIV_ASSIGN
	|   MOD_ASSIGN
	|   ADD_ASSIGN
	|   SUB_ASSIGN
	|   LEFT_ASSIGN
	|   RIGHT_ASSIGN
	|   AND_ASSIGN
	|   XOR_ASSIGN
	|   OR_ASSIGN

constant_expr
    ::= expr_no_assignment

private invariant_qualifier
    ::= INVARIANT

private interpolation_qualifier
    ::= SMOOTH
	|   FLAT
	|   NOPERSPECTIVE
	|   EXPLICITINTERPAMD
	|   PERVERTEXNV
	|   PERPRIMITIVENV
	|   PERVIEWNV
	|   PERTASKNV

// ****************
// *** Function ***
// ****************
function_prototype
    ::= attribute? function_declarator RIGHT_PAREN attribute?
    {   pin=2 }

private function_declarator
    ::= function_header func_header_with_params?

function_header
    ::= fully_specified_type variable_identifier LEFT_PAREN

private recover_func_header_with_params ::= !(RIGHT_PAREN)

func_header_with_params
    ::= parameter_declaration (COMMA parameter_declaration)*
    {   recoverWhile=recover_func_header_with_params    }

private parameter_declaration
    ::= type_qualifier? (parameter_declarator | parameter_type_specifier)

parameter_declarator
    ::= type_specifier variable_identifier array_specifier?

private parameter_type_specifier
    ::= type_specifier

function_call
    ::= function_call_or_method

private function_call_or_method
    ::= function_call_generic

private function_call_generic
    ::= function_call_header_with_parameters RIGHT_PAREN
	|   function_call_header_no_parameters RIGHT_PAREN

private function_call_header_no_parameters
    ::= function_identifier LEFT_PAREN VOID?

private recover_function_call_header_with_parameters ::= !(RIGHT_PAREN)

private function_call_header_with_parameters
    ::= function_call_header expr_no_assignment (COMMA expr_no_assignment)*
    {   recoverWhile=recover_function_call_header_with_parameters   }

private function_call_header
    ::= function_identifier LEFT_PAREN

private function_identifier
    ::= variable_identifier array_specifier?
    |   type_specifier
    |   non_uniform_qualifier

// **************
// *** Struct ***
// **************
block_structure_wrapper ::=
    block_structure (variable_identifier array_specifier?)?

block_structure
    ::= type_qualifier type_name LEFT_BRACE struct_declaration_list RIGHT_BRACE

struct_specifier
    ::= STRUCT type_name? LEFT_BRACE struct_declaration_list RIGHT_BRACE
    {   pin=1  }

private struct_declaration_list
    ::= struct_declaration+

struct_declaration
    ::= fully_specified_type struct_declarator_list SEMICOLON
    |   pp_statement
    {   pin=1 }

private recover_struct_declaration_list ::= !(SEMICOLON|COMMA|RIGHT_BRACE)

private struct_declarator_list
    ::= struct_declarator (COMMA struct_declarator)*
    {   recoverWhile=recover_struct_declaration_list    }

struct_declarator
    ::= variable_identifier array_specifier?

// **************
// *** Types ****
// **************
type_name ::=
    TYPE_NAME_IDENTIFIER

private fully_specified_type
    ::= type_qualifier? type_specifier

type_specifier
    ::= (type_specifier_builtin|type_specifier_user) type_parameter_specifier? array_specifier?

type_parameter_specifier
    ::= LEFT_ANGLE type_parameter_specifier_list RIGHT_ANGLE

type_specifier_builtin
    ::= 	VOID |
        	FLOAT |
        	DOUBLE |
        	INT |
        	UINT |
        	BOOL |
            FLOAT16_T |
            FLOAT32_T |
            FLOAT64_T |
            INT64_T |
            UINT64_T |
            INT32_T |
            UINT32_T |
            INT16_T |
            UINT16_T |
            INT8_T |
            UINT8_T |
            VEC2 |
            VEC3 |
            VEC4 |
            DVEC2 |
            DVEC3 |
            DVEC4 |
            BVEC2 |
            BVEC3 |
            BVEC4 |
            IVEC2 |
            IVEC3 |
            IVEC4 |
            UVEC2 |
            UVEC3 |
            UVEC4 |
        	MAT2 |
        	MAT3 |
        	MAT4 |
        	MAT2X2 |
        	MAT2X3 |
        	MAT2X4 |
        	MAT3X2 |
        	MAT3X3 |
        	MAT3X4 |
        	MAT4X2 |
        	MAT4X3 |
        	MAT4X4 |
        	DMAT2 |
        	DMAT3 |
        	DMAT4 |
        	DMAT2X2 |
        	DMAT2X3 |
        	DMAT2X4 |
        	DMAT3X2 |
        	DMAT3X3 |
        	DMAT3X4 |
        	DMAT4X2 |
        	DMAT4X3 |
        	DMAT4X4 |
        	ATOMIC_UINT |
        	SAMPLER2D |
        	SAMPLER3D |
        	SAMPLERCUBE |
        	SAMPLER2DSHADOW |
        	SAMPLERCUBESHADOW |
        	SAMPLER2DARRAY |
        	SAMPLER2DARRAYSHADOW |
        	SAMPLERCUBEARRAY |
        	SAMPLERCUBEARRAYSHADOW |
        	ISAMPLER2D |
        	ISAMPLER3D |
        	ISAMPLERCUBE |
        	ISAMPLER2DARRAY |
        	ISAMPLERCUBEARRAY |
        	USAMPLER2D |
        	USAMPLER3D |
        	USAMPLERCUBE |
        	USAMPLER2DARRAY |
        	USAMPLERCUBEARRAY |
        	SAMPLER1D |
        	SAMPLER1DSHADOW |
        	SAMPLER1DARRAY |
        	SAMPLER1DARRAYSHADOW |
        	ISAMPLER1D |
        	ISAMPLER1DARRAY |
        	USAMPLER1D |
        	USAMPLER1DARRAY |
        	SAMPLER2DRECT |
        	SAMPLER2DRECTSHADOW |
        	ISAMPLER2DRECT |
        	USAMPLER2DRECT |
        	SAMPLERBUFFER |
        	ISAMPLERBUFFER |
        	USAMPLERBUFFER |
        	SAMPLER2DMS |
        	ISAMPLER2DMS |
        	USAMPLER2DMS |
        	SAMPLER2DMSARRAY |
        	ISAMPLER2DMSARRAY |
        	USAMPLER2DMSARRAY |
        	IMAGE2D |
        	IIMAGE2D |
        	UIMAGE2D |
        	IMAGE3D |
        	IIMAGE3D |
        	UIMAGE3D |
        	IMAGECUBE |
        	IIMAGECUBE |
        	UIMAGECUBE |
        	IMAGEBUFFER |
        	IIMAGEBUFFER |
        	UIMAGEBUFFER |
        	IMAGE1D |
        	IIMAGE1D |
        	UIMAGE1D |
        	IMAGE1DARRAY |
        	IIMAGE1DARRAY |
        	UIMAGE1DARRAY |
        	IMAGE2DRECT |
        	IIMAGE2DRECT |
        	UIMAGE2DRECT |
        	IMAGE2DARRAY |
        	IIMAGE2DARRAY |
        	UIMAGE2DARRAY |
        	IMAGECUBEARRAY |
        	IIMAGECUBEARRAY |
        	UIMAGECUBEARRAY |
        	IMAGE2DMS |
        	IIMAGE2DMS |
        	UIMAGE2DMS |
        	IMAGE2DMSARRAY |
        	IIMAGE2DMSARRAY |
        	UIMAGE2DMSARRAY

type_specifier_user
    ::= spirv_type_specifier | struct_specifier | type_name

// ******************
// *** Qualifier ****
// ******************
type_qualifier
    ::= single_type_qualifier+

private single_type_qualifier
    ::= layout_qualifier
    |   storage_qualifier
	|   precision_qualifier
	|   interpolation_qualifier
	|   invariant_qualifier
	|   precise_qualifier
	|   non_uniform_qualifier
	|   spirv_storage_class_qualifier
	|   spirv_decorate_qualifier
	|   SPIRV_BY_REFERENCE
	|   SPIRV_LITERAL

layout_qualifier
    ::= LAYOUT LEFT_PAREN layout_qualifier_id_list RIGHT_PAREN
    {   pin=1 }

private recover_layout_qualifier_list ::= !(SEMICOLON|RIGHT_PAREN)

private layout_qualifier_id_list
    ::= layout_qualifier_id (COMMA layout_qualifier_id)*
    {   recoverWhile=recover_layout_qualifier_list    }

layout_qualifier_id
    ::= variable_identifier (EQUAL constant_expr)?
	|   SHARED
    {   pin(".*")=1 }

precise_qualifier
    ::= PRECISE

non_uniform_qualifier
    ::= NONUNIFORM

private type_name_list
    ::= variable_identifier (COMMA variable_identifier)*

array_specifier
    ::= (LEFT_BRACKET expr_no_assignment? RIGHT_BRACKET)+

private type_parameter_specifier_list
    ::= unary_expr (COMMA unary_expr)*

private storage_qualifier
    ::= CONST | INOUT | IN | OUT | CENTROID | UNIFORM | SHARED | BUFFER | ATTR | VARYING | PATCH | SAMPLE | HITATTRNV
    | HITATTREXT | PAYLOADNV | PAYLOADEXT | PAYLOADINNV | PAYLOADINEXT | CALLDATANV | CALLDATAEXT | CALLDATAINNV | CALLDATAINEXT
    | COHERENT | DEVICECOHERENT | QUEUEFAMILYCOHERENT | WORKGROUPCOHERENT | SUBGROUPCOHERENT | NONPRIVATE | SHADERCALLCOHERENT
    | VOLATILE | RESTRICT | READONLY | WRITEONLY | SUBROUTINE | SUBROUTINE LEFT_PAREN type_name_list RIGHT_PAREN

private precision_qualifier
    ::= HIGH_PRECISION
	|   MEDIUM_PRECISION
	|   LOW_PRECISION

// ******************
// *** Attribute ****
// ******************
attribute
    ::= LEFT_BRACKET LEFT_BRACKET attribute_list RIGHT_BRACKET RIGHT_BRACKET
    {   pin=2   }

private attribute_list
    ::= single_attribute (COMMA single_attribute)*

single_attribute
    ::= variable_identifier
	|   variable_identifier LEFT_PAREN constant_expr RIGHT_PAREN

// **************
// *** SPIR-V ****
// **************
private spirv_requirements_list
    ::= spirv_requirements_parameter (COMMA spirv_requirements_parameter)*

spirv_requirements_parameter
    ::= variable_identifier EQUAL LEFT_BRACKET spirv_extension_list RIGHT_BRACKET
	|   variable_identifier EQUAL LEFT_BRACKET spirv_capability_list RIGHT_BRACKET

private spirv_extension_list
    ::= STRING_LITERAL (COMMA STRING_LITERAL)*

private spirv_capability_list
    ::= INTCONSTANT (COMMA INTCONSTANT)*

spirv_execution_mode_qualifier
    ::= SPIRV_EXECUTION_MODE LEFT_PAREN INTCONSTANT RIGHT_PAREN
	|   SPIRV_EXECUTION_MODE LEFT_PAREN spirv_requirements_list COMMA INTCONSTANT RIGHT_PAREN
	|   SPIRV_EXECUTION_MODE LEFT_PAREN INTCONSTANT COMMA spirv_execution_mode_parameter_list RIGHT_PAREN
	|   SPIRV_EXECUTION_MODE LEFT_PAREN spirv_requirements_list COMMA INTCONSTANT COMMA spirv_execution_mode_parameter_list RIGHT_PAREN
	|   SPIRV_EXECUTION_MODE_ID LEFT_PAREN INTCONSTANT COMMA spirv_execution_mode_id_parameter_list RIGHT_PAREN
	|   SPIRV_EXECUTION_MODE_ID LEFT_PAREN spirv_requirements_list COMMA INTCONSTANT COMMA spirv_execution_mode_id_parameter_list RIGHT_PAREN

private spirv_execution_mode_parameter_list
    ::= spirv_execution_mode_parameter (COMMA spirv_execution_mode_parameter)*

spirv_execution_mode_parameter
    ::= FLOATCONSTANT
	|   INTCONSTANT
	|   UINTCONSTANT
	|   BOOLCONSTANT
	|   STRING_LITERAL

private spirv_execution_mode_id_parameter_list
    ::= constant_expr (COMMA constant_expr)*

spirv_storage_class_qualifier
    ::= SPIRV_STORAGE_CLASS LEFT_PAREN INTCONSTANT RIGHT_PAREN
	|   SPIRV_STORAGE_CLASS LEFT_PAREN spirv_requirements_list COMMA INTCONSTANT RIGHT_PAREN

spirv_decorate_qualifier
    ::= SPIRV_DECORATE LEFT_PAREN INTCONSTANT RIGHT_PAREN
	|   SPIRV_DECORATE LEFT_PAREN spirv_requirements_list COMMA INTCONSTANT RIGHT_PAREN
	|   SPIRV_DECORATE LEFT_PAREN INTCONSTANT COMMA spirv_decorate_parameter_list RIGHT_PAREN
	|   SPIRV_DECORATE LEFT_PAREN spirv_requirements_list COMMA INTCONSTANT COMMA spirv_decorate_parameter_list RIGHT_PAREN
	|   SPIRV_DECORATE_ID LEFT_PAREN INTCONSTANT COMMA spirv_decorate_id_parameter_list RIGHT_PAREN
	|   SPIRV_DECORATE_ID LEFT_PAREN spirv_requirements_list COMMA INTCONSTANT COMMA spirv_decorate_id_parameter_list RIGHT_PAREN
	|   SPIRV_DECORATE_STRING LEFT_PAREN INTCONSTANT COMMA spirv_decorate_string_parameter_list RIGHT_PAREN
	|   SPIRV_DECORATE_STRING LEFT_PAREN spirv_requirements_list COMMA INTCONSTANT COMMA spirv_decorate_string_parameter_list RIGHT_PAREN

private spirv_decorate_parameter_list
    ::= spirv_decorate_parameter (COMMA spirv_decorate_parameter)*

spirv_decorate_parameter
    ::= FLOATCONSTANT
	|   INTCONSTANT
	|   UINTCONSTANT
	|   BOOLCONSTANT

private spirv_decorate_id_parameter_list
    ::= constant_expr (COMMA constant_expr)*

private spirv_decorate_string_parameter_list
    ::= STRING_LITERAL (COMMA STRING_LITERAL)*

spirv_type_specifier
    ::= SPIRV_TYPE LEFT_PAREN spirv_instruction_qualifier_list COMMA spirv_type_parameter_list RIGHT_PAREN
	|   SPIRV_TYPE LEFT_PAREN spirv_requirements_list COMMA spirv_instruction_qualifier_list COMMA spirv_type_parameter_list RIGHT_PAREN
	|   SPIRV_TYPE LEFT_PAREN spirv_instruction_qualifier_list RIGHT_PAREN
	|   SPIRV_TYPE LEFT_PAREN spirv_requirements_list COMMA spirv_instruction_qualifier_list RIGHT_PAREN

private spirv_type_parameter_list
    ::= spirv_type_parameter (COMMA spirv_type_parameter)*

spirv_type_parameter
    ::= constant_expr

spirv_instruction_qualifier
    ::= SPIRV_INSTRUCTION LEFT_PAREN spirv_instruction_qualifier_list RIGHT_PAREN
	|   SPIRV_INSTRUCTION LEFT_PAREN spirv_requirements_list COMMA spirv_instruction_qualifier_list RIGHT_PAREN

private spirv_instruction_qualifier_list
    ::= spirv_instruction_qualifier_id (COMMA spirv_instruction_qualifier_id)*

spirv_instruction_qualifier_id
    ::= variable_identifier EQUAL STRING_LITERAL
	|   variable_identifier EQUAL INTCONSTANT

// *********************
// *** Preprocessor ****
// *********************
pp_statement
    ::=  pp_literal (FLOATCONSTANT|INTCONSTANT|STRING_LITERAL|BOOLCONSTANT|PP_TEXT)*
    |    (PP_UNDEF|PP_IFDEF|PP_IFNDEF) variable_identifier PP_END
    |    pp_include_declaration PP_END
    |    pp_define_declaration PP_END
    |    pp_conditional PP_END
    |    pp_version_declaration PP_END
    |    pp_extension PP_END
    |    pp_line PP_END
    |    macro_literal INTCONSTANT PP_END

private pp_extension
    ::= PP_EXTENSION variable_identifier COLON ('require'|'enable'|'warn'|'disable')
    {   pin(".*")=1   }

pp_include_declaration
    ::= PP_INCLUDE (STRING_LITERAL | pp_include_brackets)
    {   pin(".*")=1  generateTokenAccessors=true }

pp_include_brackets
    ::= LEFT_ANGLE pp_include_path (SLASH pp_include_path)* RIGHT_ANGLE

pp_include_path
    ::= variable_identifier (DOT variable_identifier)?

private pp_version_declaration
    ::= PP_VERSION INTCONSTANT ('core'|'es'|'compatibility')?
    {   pin(".*")=1   }

private pp_line
    ::= PP_LINE INTCONSTANT INTCONSTANT?
    {   pin(".*")=1   }

private pp_conditional
    ::= (PP_IF|PP_ELIF) expr_no_assignment
    |   PP_ENDIF
    |   PP_ELSE
    |   HASH
    {   pin(".*")=1   }

private pp_define_declaration
    ::= PP_DEFINE (pp_define_function|pp_type_declaration|pp_single_declaration)
    {   pin(".*")=1   }

private recover_pp_define_function ::= !(RIGHT_PAREN|PP_END)

pp_single_declaration
    ::= variable_identifier expr?

pp_type_declaration
    ::= variable_identifier (type_specifier_builtin|single_type_qualifier)

pp_define_function
    ::= variable_identifier LEFT_PAREN pp_define_params RIGHT_PAREN expr
    {   pin=2 }

private pp_define_params
    ::= pp_define_param  (COMMA pp_define_param)*
    {   pin=1 recoverWhile=recover_pp_define_function   }

pp_define_param
    ::= variable_identifier

pp_literal
    ::= PP_PRAGMA
    |   PP_ERROR

macro_literal
    ::= MACRO_LINE
    |   MACRO_FILE
    |   MACRO_VERSION
