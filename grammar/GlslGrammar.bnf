{
    parserClass="glsl._GlslParser"
    psiClassPrefix="Glsl"
    psiImplClassSuffix="Impl"
    psiPackage="glsl.psi.interfaces"
    psiImplPackage="glsl.psi.impl"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    elementTypeHolderClass="glsl.GlslTypes"
    elementTypeClass="glsl.plugin.language.GlslElementType"
    tokenTypeClass="glsl.plugin.language.GlslTokenType"

    implements("variable_identifier|type_name")="glsl.plugin.psi.GlslIdentifier"
    mixin("variable_identifier|type_name")="glsl.plugin.psi.GlslIdentifierImpl"
    mixin("pp_include_path")="glsl.plugin.psi.GlslInclude"
    implements("expr")="glsl.plugin.psi.GlslExprType"
    mixin("expr")="glsl.plugin.psi.GlslExprTypeImpl"
    // Types
    implements("struct_specifier")="glsl.plugin.psi.named.GlslNamedUserType"
    mixin("struct_specifier")="glsl.plugin.psi.named.GlslNamedStructSpecifier"
    implements("block_structure")="glsl.plugin.psi.named.GlslNamedUserType"
    mixin("block_structure")="glsl.plugin.psi.named.GlslNamedBlockStructure"
    // Identifiers
    implements("function_header")="glsl.plugin.psi.named.GlslNamedIdentifier"
    mixin("function_header")="glsl.plugin.psi.named.GlslNamedFunctionHeader"
    implements("parameter_declarator")="glsl.plugin.psi.named.GlslNamedIdentifier"
    mixin("parameter_declarator")="glsl.plugin.psi.named.GlslNamedParameterDeclarator"
    implements("single_declaration")="glsl.plugin.psi.named.GlslNamedIdentifier"
    mixin("single_declaration")="glsl.plugin.psi.named.GlslNamedSingleDeclaration"
    implements("init_declarator_variable")="glsl.plugin.psi.named.GlslNamedIdentifier"
    mixin("init_declarator_variable")="glsl.plugin.psi.named.GlslNamedInitDeclaratorVariable"
    implements("block_structure_wrapper")="glsl.plugin.psi.named.GlslNamedIdentifier"
    mixin("block_structure_wrapper")="glsl.plugin.psi.named.GlslNamedBlockStructureWrapper"
    implements("struct_declarator")="glsl.plugin.psi.named.GlslNamedIdentifier"
    mixin("struct_declarator")="glsl.plugin.psi.named.GlslNamedStructDeclarator"
    implements("declaration_identifier_wrapper")="glsl.plugin.psi.named.GlslNamedIdentifier"
    mixin("declaration_identifier_wrapper")="glsl.plugin.psi.named.GlslNamedDeclarationIdentifierWrapper"

    extends("expr_no_assignment|assignment_expr")=expr
    extends("(comma_seperated|conditional|shift|relational|equality|and|exclusive_or|inclusive_or|logical_and|logical_xor|logical_or|mul|add|unary)_expr")=expr_no_assignment
    extends("postfix_inc|postfix_field_selection|postfix_array_index|primary_expr|function_call")=postfix_expr

    name("postfix.*|.*expr")="expression"
    name(".*statement|case_label")="statement"
    name(".*operator")="operator"
    name(".*qualifier")="qualifier"
    name("block_structure|function_prototype|single_declaration")="declration"
    name("type_specifier")="type"

    tokens = [
        LINE_COMMENT='LINE_COMMENT'
        MULTILINE_COMMENT='MULTILINE_COMMENT'
        MACRO_EXPANSION='MACRO_EXPANSION'
        BACKSLASH='BACKSLASH'
    ]
}

root ::= translation_unit*

private translation_unit
    ::= external_declaration

external_declaration
    ::= pp_statement
    |   function_definition
    |   declaration
    |   SEMICOLON

// *******************
// *** Declaration ***
// *******************
declaration
    ::= function_prototype SEMICOLON
    |   PRECISION precision_qualifier type_specifier SEMICOLON
	|   block_structure_wrapper SEMICOLON
	|   init_declarator_list SEMICOLON
	|   type_qualifier identifier_list? SEMICOLON
	|   spirv_instruction_qualifier function_prototype SEMICOLON
	|   spirv_execution_mode_qualifier SEMICOLON
    {   pin(".*")=1 }

function_definition
    ::= function_prototype compound_statement_no_new_scope

variable_identifier
    ::= IDENTIFIER

private init_declarator_list
    ::= single_declaration (COMMA init_declarator_variable array_specifier? (EQUAL initializer)?)*
    {   pin(".*")=1 }

init_declarator_variable
    ::= variable_identifier

single_declaration
    ::= fully_specified_type variable_identifier array_specifier? EQUAL initializer
    |   fully_specified_type variable_identifier EQUAL initializer
    |   fully_specified_type variable_identifier array_specifier?
    |   fully_specified_type
    {   pin(".*")="EQUAL" }

private initializer_list
    ::= initializer (COMMA initializer)*

private initializer
    ::= LEFT_BRACE initializer_list COMMA RIGHT_BRACE
	|   LEFT_BRACE initializer_list? RIGHT_BRACE
	|   expr_no_assignment

private identifier_list
	::= declaration_identifier_wrapper (COMMA declaration_identifier_wrapper)*

declaration_identifier_wrapper ::= variable_identifier

// *****************
// *** Statement ***
// *****************
statement
    ::= compound_statement
    |   simple_statement

private recover_statement ::= !(RIGHT_BRACE)

private statement_list
    ::= statement*
    {   recoverWhile=recover_statement  }

compound_statement
    ::= LEFT_BRACE statement_list? RIGHT_BRACE
    {   pin=2   }

compound_statement_no_new_scope
    ::= LEFT_BRACE statement_list? RIGHT_BRACE
    {   pin=2   }

private statement_no_new_scope
    ::= compound_statement_no_new_scope
	|   simple_statement

private statement_scoped
    ::= compound_statement
    |   simple_statement

private simple_statement
    ::= declaration_statement
    |   expr_statement
	|   selection_statement
	|   switch_statement
	|   iteration_statement
	|   jump_statement
	|   case_label
	|   demote_statement
	|   pp_statement

private expr_statement
    ::= expr SEMICOLON
    {   pin=1   }

private declaration_statement
    ::= declaration
    |   SEMICOLON

private demote_statement
    ::= DEMOTE SEMICOLON
    {   pin=1   }

selection_statement
    ::= attribute? selection_statement_nonattributed

private selection_statement_nonattributed
    ::= IF LEFT_PAREN expr RIGHT_PAREN selection_rest_statement
    {   pin=1   }

private selection_rest_statement
    ::= statement_scoped (ELSE statement_scoped)?

switch_statement
    ::= attribute? switch_statement_nonattributed

private switch_statement_nonattributed
    ::= SWITCH LEFT_PAREN expr RIGHT_PAREN LEFT_BRACE switch_statement_list RIGHT_BRACE
    {   pin=1   }

private switch_statement_list
    ::= statement_list

case_label
    ::= CASE expr COLON
	|   DEFAULT COLON
	{   pin(".*")=1    }

iteration_statement
    ::= attribute? iteration_statement_nonattributed

private iteration_statement_nonattributed
    ::= WHILE LEFT_PAREN condition RIGHT_PAREN statement_no_new_scope
	|   DO statement WHILE LEFT_PAREN expr RIGHT_PAREN SEMICOLON
	|   FOR LEFT_PAREN for_init_statement for_rest_statement RIGHT_PAREN statement_no_new_scope
    {   pin(".*")=1   }

private for_init_statement
    ::= expr_statement
	|   declaration_statement

private conditionopt
    ::= condition?

condition
    ::= expr (variable_identifier EQUAL initializer)?

for_rest_statement
    ::= conditionopt SEMICOLON expr?
    {   pin=1   }

jump_statement
    ::= CONTINUE SEMICOLON
	|   BREAK SEMICOLON
	|   RETURN expr? SEMICOLON
	|   DISCARD SEMICOLON
	|   TERMINATE_INVOCATION SEMICOLON
	|   TERMINATE_RAY SEMICOLON
	|   IGNORE_INTERSECTION SEMICOLON
	{   pin(".*")=1    }

// ******************
// *** Expression ***
// ******************
expr
    ::= assignment_expr
    |   expr_no_assignment (COMMA expr_no_assignment)*

// This rule should be like 'conditional_expr' in the original grammar, which have all
// expressions without assignment
expr_no_assignment
    ::= conditional_expr
    |   shift_expr
    |   relational_expr
    |   equality_expr
    |   and_expr
    |   exclusive_or_expr
    |   inclusive_or_expr
    |   logical_and_expr
    |   logical_xor_expr
    |   logical_or_expr
    |   mul_expr
    |   add_expr
    |   unary_expr

postfix_expr
    ::= postfix_array_index
    |   function_call
    |   postfix_field_selection
    |   postfix_inc
    |   primary_expr

private integer_expression
    ::= expr

postfix_inc
    ::= postfix_expr (INC_OP|DEC_OP)

postfix_struct_member
    ::= function_call
    |   variable_identifier (LEFT_BRACKET integer_expression RIGHT_BRACKET)?

postfix_field_selection
    ::= postfix_expr (DOT postfix_struct_member)+
    {   pin(".*")=1    }

postfix_array_index
    ::= postfix_expr (LEFT_BRACKET integer_expression RIGHT_BRACKET)+

primary_expr
    ::= variable_identifier
    |   LEFT_PAREN expr RIGHT_PAREN
    |   FLOATCONSTANT
    |   INTCONSTANT
    |   UINTCONSTANT
	|   BOOLCONSTANT
	|   STRING_LITERAL
    |   DOUBLECONSTANT
    |   MACRO_LINE
    |   MACRO_FILE
    |   MACRO_VERSION
    {   generateTokenAccessors=true }

unary_expr
    ::= (INC_OP | DEC_OP) postfix_expr
    |   unary_operator postfix_expr
    |   postfix_expr

private unary_operator
    ::= PLUS
    |   DASH
    |   BANG
    |   TILDE

mul_expr
    ::= expr_no_assignment (STAR | SLASH | PERCENT) expr_no_assignment

add_expr
    ::= expr_no_assignment (PLUS | DASH) expr_no_assignment

shift_expr
    ::= expr_no_assignment (LEFT_OP | RIGHT_OP) expr_no_assignment

relational_expr
    ::= expr_no_assignment (LEFT_ANGLE | RIGHT_ANGLE | LE_OP | GE_OP) expr_no_assignment

equality_expr
    ::= expr_no_assignment (EQ_OP | NE_OP) expr_no_assignment

and_expr
    ::= expr_no_assignment AMPERSAND expr_no_assignment

exclusive_or_expr
    ::= expr_no_assignment CARET expr_no_assignment

inclusive_or_expr
    ::= expr_no_assignment VERTICAL_BAR expr_no_assignment

logical_and_expr
    ::= expr_no_assignment AND_OP expr_no_assignment

logical_xor_expr
    ::= expr_no_assignment XOR_OP expr_no_assignment

logical_or_expr
    ::= expr_no_assignment OR_OP expr_no_assignment

conditional_expr
    ::= expr_no_assignment QUESTION expr_no_assignment COLON expr_no_assignment

assignment_expr
    ::= unary_expr assignment_operator expr
    {   pin(".*")=assignment_operator}

assignment_operator
    ::= EQUAL
	|   MUL_ASSIGN
	|   DIV_ASSIGN
	|   MOD_ASSIGN
	|   ADD_ASSIGN
	|   SUB_ASSIGN
	|   LEFT_ASSIGN
	|   RIGHT_ASSIGN
	|   AND_ASSIGN
	|   XOR_ASSIGN
	|   OR_ASSIGN

constant_expr
    ::= expr_no_assignment

private invariant_qualifier
    ::= INVARIANT

private interpolation_qualifier
    ::= SMOOTH
	|   FLAT
	|   NOPERSPECTIVE
	|   EXPLICITINTERPAMD
	|   PERVERTEXNV
	|   PERPRIMITIVENV
	|   PERVIEWNV
	|   PERTASKNV

// ****************
// *** Function ***
// ****************
function_prototype
    ::= attribute? function_declarator RIGHT_PAREN attribute?
    {   pin=2 }

private function_declarator
    ::= function_header func_header_with_params?

function_header
    ::= fully_specified_type variable_identifier LEFT_PAREN

private recover_func_header_with_params ::= !(RIGHT_PAREN)

func_header_with_params
    ::= parameter_declaration (COMMA parameter_declaration)*
    {   recoverWhile=recover_func_header_with_params    }

private parameter_declaration
    ::= type_qualifier? (parameter_declarator | parameter_type_specifier)

parameter_declarator
    ::= type_specifier variable_identifier array_specifier?

private parameter_type_specifier
    ::= type_specifier

function_call
    ::= function_call_or_method

private function_call_or_method
    ::= function_call_generic

private function_call_generic
    ::= function_call_header_with_parameters RIGHT_PAREN
	|   function_call_header_no_parameters RIGHT_PAREN

private function_call_header_no_parameters
    ::= function_identifier LEFT_PAREN VOID?

private recover_function_call_header_with_parameters ::= !(RIGHT_PAREN)

private function_call_header_with_parameters
    ::= function_call_header expr_no_assignment (COMMA expr_no_assignment)*
    {   recoverWhile=recover_function_call_header_with_parameters   }

private function_call_header
    ::= function_identifier LEFT_PAREN

private function_identifier
    ::= variable_identifier array_specifier?
    |   type_specifier
    |   non_uniform_qualifier

// **************
// *** Struct ***
// **************
block_structure_wrapper ::=
    block_structure (variable_identifier array_specifier?)?

block_structure
    ::= type_qualifier type_name LEFT_BRACE struct_declaration_list RIGHT_BRACE

struct_specifier
    ::= STRUCT type_name? LEFT_BRACE struct_declaration_list RIGHT_BRACE
    {   pin=1  }

private struct_declaration_list
    ::= struct_declaration+

struct_declaration
    ::= fully_specified_type struct_declarator_list SEMICOLON
    |   pp_statement
    {   pin=1 }

private recover_struct_declaration_list ::= !(SEMICOLON|COMMA|RIGHT_BRACE)

private struct_declarator_list
    ::= struct_declarator (COMMA struct_declarator)*
    {   recoverWhile=recover_struct_declaration_list    }

struct_declarator
    ::= variable_identifier array_specifier?

// **************
// *** Types ****
// **************
type_name ::=
    TYPE_NAME_IDENTIFIER

private fully_specified_type
    ::= type_qualifier? type_specifier

type_specifier
    ::= (type_specifier_builtin|type_specifier_user) type_parameter_specifier? array_specifier?

type_parameter_specifier
    ::= LEFT_ANGLE type_parameter_specifier_list RIGHT_ANGLE

type_specifier_builtin
    ::= 	VOID |
        	FLOAT |
        	DOUBLE |
        	INT |
        	UINT |
        	BOOL |
            FLOAT16_T |
            FLOAT32_T |
            FLOAT64_T |
            INT64_T |
            UINT64_T |
            INT32_T |
            UINT32_T |
            INT16_T |
            UINT16_T |
            INT8_T |
            UINT8_T |
            VEC2 |
            VEC3 |
            VEC4 |
            DVEC2 |
            DVEC3 |
            DVEC4 |
            BVEC2 |
            BVEC3 |
            BVEC4 |
            IVEC2 |
            IVEC3 |
            IVEC4 |
            UVEC2 |
            UVEC3 |
            UVEC4 |
        	MAT2 |
        	MAT3 |
        	MAT4 |
        	MAT2X2 |
        	MAT2X3 |
        	MAT2X4 |
        	MAT3X2 |
        	MAT3X3 |
        	MAT3X4 |
        	MAT4X2 |
        	MAT4X3 |
        	MAT4X4 |
        	DMAT2 |
        	DMAT3 |
        	DMAT4 |
        	DMAT2X2 |
        	DMAT2X3 |
        	DMAT2X4 |
        	DMAT3X2 |
        	DMAT3X3 |
        	DMAT3X4 |
        	DMAT4X2 |
        	DMAT4X3 |
        	DMAT4X4 |
        	ATOMIC_UINT |
        	SAMPLER2D |
        	SAMPLER3D |
        	SAMPLERCUBE |
        	SAMPLER2DSHADOW |
        	SAMPLERCUBESHADOW |
        	SAMPLER2DARRAY |
        	SAMPLER2DARRAYSHADOW |
        	SAMPLERCUBEARRAY |
        	SAMPLERCUBEARRAYSHADOW |
        	ISAMPLER2D |
        	ISAMPLER3D |
        	ISAMPLERCUBE |
        	ISAMPLER2DARRAY |
        	ISAMPLERCUBEARRAY |
        	USAMPLER2D |
        	USAMPLER3D |
        	USAMPLERCUBE |
        	USAMPLER2DARRAY |
        	USAMPLERCUBEARRAY |
        	SAMPLER1D |
        	SAMPLER1DSHADOW |
        	SAMPLER1DARRAY |
        	SAMPLER1DARRAYSHADOW |
        	ISAMPLER1D |
        	ISAMPLER1DARRAY |
        	USAMPLER1D |
        	USAMPLER1DARRAY |
        	SAMPLER2DRECT |
        	SAMPLER2DRECTSHADOW |
        	ISAMPLER2DRECT |
        	USAMPLER2DRECT |
        	SAMPLERBUFFER |
        	ISAMPLERBUFFER |
        	USAMPLERBUFFER |
        	SAMPLER2DMS |
        	ISAMPLER2DMS |
        	USAMPLER2DMS |
        	SAMPLER2DMSARRAY |
        	ISAMPLER2DMSARRAY |
        	USAMPLER2DMSARRAY |
        	IMAGE2D |
        	IIMAGE2D |
        	UIMAGE2D |
        	IMAGE3D |
        	IIMAGE3D |
        	UIMAGE3D |
        	IMAGECUBE |
        	IIMAGECUBE |
        	UIMAGECUBE |
        	IMAGEBUFFER |
        	IIMAGEBUFFER |
        	UIMAGEBUFFER |
        	IMAGE1D |
        	IIMAGE1D |
        	UIMAGE1D |
        	IMAGE1DARRAY |
        	IIMAGE1DARRAY |
        	UIMAGE1DARRAY |
        	IMAGE2DRECT |
        	IIMAGE2DRECT |
        	UIMAGE2DRECT |
        	IMAGE2DARRAY |
        	IIMAGE2DARRAY |
        	UIMAGE2DARRAY |
        	IMAGECUBEARRAY |
        	IIMAGECUBEARRAY |
        	UIMAGECUBEARRAY |
        	IMAGE2DMS |
        	IIMAGE2DMS |
        	UIMAGE2DMS |
        	IMAGE2DMSARRAY |
        	IIMAGE2DMSARRAY |
        	UIMAGE2DMSARRAY

type_specifier_user
    ::= spirv_type_specifier | struct_specifier | type_name

// ******************
// *** Qualifier ****
// ******************
type_qualifier
    ::= single_type_qualifier+

private single_type_qualifier
    ::= layout_qualifier
    |   storage_qualifier
	|   precision_qualifier
	|   interpolation_qualifier
	|   invariant_qualifier
	|   precise_qualifier
	|   non_uniform_qualifier
	|   spirv_storage_class_qualifier
	|   spirv_decorate_qualifier
	|   SPIRV_BY_REFERENCE
	|   SPIRV_LITERAL

layout_qualifier
    ::= LAYOUT LEFT_PAREN layout_qualifier_id_list RIGHT_PAREN
    {   pin=1 }

private recover_layout_qualifier_list ::= !(SEMICOLON|RIGHT_PAREN)

private layout_qualifier_id_list
    ::= layout_qualifier_id (COMMA layout_qualifier_id)*
    {   recoverWhile=recover_layout_qualifier_list    }

layout_qualifier_id
    ::= variable_identifier (EQUAL constant_expr)?
	|   SHARED
    {   pin(".*")=1 }

precise_qualifier
    ::= PRECISE

non_uniform_qualifier
    ::= NONUNIFORM

private type_name_list
    ::= variable_identifier (COMMA variable_identifier)*

array_specifier
    ::= (LEFT_BRACKET expr_no_assignment? RIGHT_BRACKET)+

private type_parameter_specifier_list
    ::= unary_expr (COMMA unary_expr)*

private storage_qualifier
    ::= CONST | INOUT | IN | OUT | CENTROID | UNIFORM | SHARED | BUFFER | ATTR | VARYING | PATCH | SAMPLE | HITATTRNV
    | HITATTREXT | PAYLOADNV | PAYLOADEXT | PAYLOADINNV | PAYLOADINEXT | CALLDATANV | CALLDATAEXT | CALLDATAINNV | CALLDATAINEXT
    | COHERENT | DEVICECOHERENT | QUEUEFAMILYCOHERENT | WORKGROUPCOHERENT | SUBGROUPCOHERENT | NONPRIVATE | SHADERCALLCOHERENT
    | VOLATILE | RESTRICT | READONLY | WRITEONLY | SUBROUTINE | SUBROUTINE LEFT_PAREN type_name_list RIGHT_PAREN

private precision_qualifier
    ::= HIGH_PRECISION
	|   MEDIUM_PRECISION
	|   LOW_PRECISION

// ******************
// *** Attribute ****
// ******************
attribute
    ::= LEFT_BRACKET LEFT_BRACKET attribute_list RIGHT_BRACKET RIGHT_BRACKET
    {   pin=2   }

private attribute_list
    ::= single_attribute (COMMA single_attribute)*

single_attribute
    ::= variable_identifier
	|   variable_identifier LEFT_PAREN constant_expr RIGHT_PAREN

// **************
// *** SPIR-V ****
// **************
private spirv_requirements_list
    ::= spirv_requirements_parameter (COMMA spirv_requirements_parameter)*

spirv_requirements_parameter
    ::= variable_identifier EQUAL LEFT_BRACKET spirv_extension_list RIGHT_BRACKET
	|   variable_identifier EQUAL LEFT_BRACKET spirv_capability_list RIGHT_BRACKET

private spirv_extension_list
    ::= STRING_LITERAL (COMMA STRING_LITERAL)*

private spirv_capability_list
    ::= INTCONSTANT (COMMA INTCONSTANT)*

spirv_execution_mode_qualifier
    ::= SPIRV_EXECUTION_MODE LEFT_PAREN INTCONSTANT RIGHT_PAREN
	|   SPIRV_EXECUTION_MODE LEFT_PAREN spirv_requirements_list COMMA INTCONSTANT RIGHT_PAREN
	|   SPIRV_EXECUTION_MODE LEFT_PAREN INTCONSTANT COMMA spirv_execution_mode_parameter_list RIGHT_PAREN
	|   SPIRV_EXECUTION_MODE LEFT_PAREN spirv_requirements_list COMMA INTCONSTANT COMMA spirv_execution_mode_parameter_list RIGHT_PAREN
	|   SPIRV_EXECUTION_MODE_ID LEFT_PAREN INTCONSTANT COMMA spirv_execution_mode_id_parameter_list RIGHT_PAREN
	|   SPIRV_EXECUTION_MODE_ID LEFT_PAREN spirv_requirements_list COMMA INTCONSTANT COMMA spirv_execution_mode_id_parameter_list RIGHT_PAREN

private spirv_execution_mode_parameter_list
    ::= spirv_execution_mode_parameter (COMMA spirv_execution_mode_parameter)*

spirv_execution_mode_parameter
    ::= FLOATCONSTANT
	|   INTCONSTANT
	|   UINTCONSTANT
	|   BOOLCONSTANT
	|   STRING_LITERAL

private spirv_execution_mode_id_parameter_list
    ::= constant_expr (COMMA constant_expr)*

spirv_storage_class_qualifier
    ::= SPIRV_STORAGE_CLASS LEFT_PAREN INTCONSTANT RIGHT_PAREN
	|   SPIRV_STORAGE_CLASS LEFT_PAREN spirv_requirements_list COMMA INTCONSTANT RIGHT_PAREN

spirv_decorate_qualifier
    ::= SPIRV_DECORATE LEFT_PAREN INTCONSTANT RIGHT_PAREN
	|   SPIRV_DECORATE LEFT_PAREN spirv_requirements_list COMMA INTCONSTANT RIGHT_PAREN
	|   SPIRV_DECORATE LEFT_PAREN INTCONSTANT COMMA spirv_decorate_parameter_list RIGHT_PAREN
	|   SPIRV_DECORATE LEFT_PAREN spirv_requirements_list COMMA INTCONSTANT COMMA spirv_decorate_parameter_list RIGHT_PAREN
	|   SPIRV_DECORATE_ID LEFT_PAREN INTCONSTANT COMMA spirv_decorate_id_parameter_list RIGHT_PAREN
	|   SPIRV_DECORATE_ID LEFT_PAREN spirv_requirements_list COMMA INTCONSTANT COMMA spirv_decorate_id_parameter_list RIGHT_PAREN
	|   SPIRV_DECORATE_STRING LEFT_PAREN INTCONSTANT COMMA spirv_decorate_string_parameter_list RIGHT_PAREN
	|   SPIRV_DECORATE_STRING LEFT_PAREN spirv_requirements_list COMMA INTCONSTANT COMMA spirv_decorate_string_parameter_list RIGHT_PAREN

private spirv_decorate_parameter_list
    ::= spirv_decorate_parameter (COMMA spirv_decorate_parameter)*

spirv_decorate_parameter
    ::= FLOATCONSTANT
	|   INTCONSTANT
	|   UINTCONSTANT
	|   BOOLCONSTANT

private spirv_decorate_id_parameter_list
    ::= constant_expr (COMMA constant_expr)*

private spirv_decorate_string_parameter_list
    ::= STRING_LITERAL (COMMA STRING_LITERAL)*

spirv_type_specifier
    ::= SPIRV_TYPE LEFT_PAREN spirv_instruction_qualifier_list COMMA spirv_type_parameter_list RIGHT_PAREN
	|   SPIRV_TYPE LEFT_PAREN spirv_requirements_list COMMA spirv_instruction_qualifier_list COMMA spirv_type_parameter_list RIGHT_PAREN
	|   SPIRV_TYPE LEFT_PAREN spirv_instruction_qualifier_list RIGHT_PAREN
	|   SPIRV_TYPE LEFT_PAREN spirv_requirements_list COMMA spirv_instruction_qualifier_list RIGHT_PAREN

private spirv_type_parameter_list
    ::= spirv_type_parameter (COMMA spirv_type_parameter)*

spirv_type_parameter
    ::= constant_expr

spirv_instruction_qualifier
    ::= SPIRV_INSTRUCTION LEFT_PAREN spirv_instruction_qualifier_list RIGHT_PAREN
	|   SPIRV_INSTRUCTION LEFT_PAREN spirv_requirements_list COMMA spirv_instruction_qualifier_list RIGHT_PAREN

private spirv_instruction_qualifier_list
    ::= spirv_instruction_qualifier_id (COMMA spirv_instruction_qualifier_id)*

spirv_instruction_qualifier_id
    ::= variable_identifier EQUAL STRING_LITERAL
	|   variable_identifier EQUAL INTCONSTANT

// *********************
// *** Preprocessor ****
// *********************
pp_statement
    ::=  pp_literal (FLOATCONSTANT|INTCONSTANT|STRING_LITERAL|BOOLCONSTANT|PP_TEXT)* PP_END
    |    (PP_UNDEF|PP_IFDEF|PP_IFNDEF) variable_identifier PP_END
    |    pp_include_declaration PP_END
    |    pp_define_declaration PP_END
    |    pp_conditional PP_END
    |    pp_version_declaration PP_END
    |    pp_extension PP_END
    |    pp_line PP_END
    |    macro_literal INTCONSTANT PP_END

private pp_extension
    ::= PP_EXTENSION variable_identifier COLON ('require'|'enable'|'warn'|'disable')
    {   pin(".*")=1   }

pp_include_declaration
    ::= PP_INCLUDE pp_include_path
    {   pin(".*")=1 }

pp_include_path
    ::= STRING_LITERAL
    |   LEFT_ANGLE variable_identifier (SLASH variable_identifier)* (DOT variable_identifier)? RIGHT_ANGLE

private pp_version_declaration
    ::= PP_VERSION INTCONSTANT ('core'|'es'|'compatibility')?
    {   pin(".*")=1   }

private pp_line
    ::= PP_LINE INTCONSTANT INTCONSTANT?
    {   pin(".*")=1   }

private pp_conditional
    ::= (PP_IF|PP_ELIF) expr_no_assignment
    |   PP_ENDIF
    |   PP_ELSE
    |   HASH
    {   pin(".*")=1   }

private pp_define_declaration
    ::= PP_DEFINE PP_TEXT*
    {   pin(".*")=1   }

pp_literal
    ::= PP_PRAGMA
    |   PP_ERROR

macro_literal
    ::= MACRO_LINE
    |   MACRO_FILE
    |   MACRO_VERSION
